# .github/workflows/container-splitter-deploy.yml

name: Build and Deploy Splitter Container

on:
  push:
    branches:
      - main
    paths:
      - "src/containers/splitter/**"
      - ".github/workflows/container-splitter-deploy.yml"
  pull_request:
    branches:
      - main
    paths:
      - "src/containers/splitter/**"
      - ".github/workflows/container-splitter-deploy.yml"
  workflow_dispatch:
    inputs:
      environment:
        description: "Environment to deploy to"
        required: true
        type: choice
        options:
          - dev
          - staging
          - prod

# Best Practice: Set default permissions to read-only for security
permissions:
  contents: read
  pull-requests: write
  id-token: write # Required for OIDC authentication with AWS
  security-events: write # Required for uploading SARIF results

# Best Practice: Cancel in-progress runs on the same branch
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true # Safe to cancel container builds

env:
  CONTAINER_NAME: splitter
  CONTAINER_PATH: ./src/containers/splitter
  AWS_REGION: us-east-1 # Override with secrets/vars as needed

jobs:
  # ============================================================================
  # Build and Scan Container Image
  # ============================================================================
  build:
    name: Build & Scan Container
    runs-on: ubuntu-latest
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}
      version: ${{ steps.meta.outputs.version }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0 # Full history for accurate versioning

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Generate image metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.CONTAINER_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build container image
        id: build
        uses: docker/build-push-action@v6
        with:
          context: ${{ env.CONTAINER_PATH }}
          file: ${{ env.CONTAINER_PATH }}/Dockerfile
          push: false
          load: true
          tags: ${{ steps.meta.outputs.tags }}
          build-args: |
            BUILD_DATE=${{ github.event.head_commit.timestamp }}
            VERSION=${{ steps.meta.outputs.version }}
            GIT_SHA=${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Save image for push job
        if: github.ref == 'refs/heads/main'
        run: |
          docker save ${{ env.CONTAINER_NAME }}:${{ github.sha }} | gzip > /tmp/container-image.tar.gz

      - name: Upload image artifact
        if: github.ref == 'refs/heads/main'
        uses: actions/upload-artifact@v6
        with:
          name: container-image-${{ github.sha }}
          path: /tmp/container-image.tar.gz
          retention-days: 1

      - name: Comment PR with scan results
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const output = `#### Container Build & Security Scan üê≥üîí
            
            **Image:** \`${{ env.CONTAINER_NAME }}:${{ github.sha }}\`
            **Digest:** \`${{ steps.build.outputs.digest }}\`
            
            ‚úÖ Container image built successfully
            ‚úÖ Trivy vulnerability scan completed
            
            Check the "Security" tab for detailed scan results.
            
            *Pushed by: @${{ github.actor }}, Action: \`${{ github.event_name }}\`*`;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: output
            })

#   # ============================================================================
#   # Push to ECR (Dev Environment)
#   # ============================================================================
#   push-dev:
#     name: Push to ECR (Dev)
#     needs: build
#     if: github.ref == 'refs/heads/main' && github.event_name == 'push'
#     runs-on: ubuntu-latest
#     environment:
#       name: dev
    
#     outputs:
#       ecr-image-uri: ${{ steps.push.outputs.image-uri }}
    
#     steps:
#       - name: Download image artifact
#         uses: actions/download-artifact@v7
#         with:
#           name: container-image-${{ github.sha }}
#           path: /tmp

#       - name: Load Docker image
#         run: |
#           docker load < /tmp/container-image.tar.gz
#           docker images

#       - name: Configure AWS Credentials (OIDC)
#         uses: aws-actions/configure-aws-credentials@v4
#         with:
#           role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
#           aws-region: ${{ vars.AWS_REGION || env.AWS_REGION }}
#           role-session-name: GitHubActions-Container-Deploy-Dev

#       - name: Login to Amazon ECR
#         id: login-ecr
#         uses: aws-actions/amazon-ecr-login@v2

#       - name: Tag and push image to ECR
#         id: push
#         env:
#           ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
#           ECR_REPOSITORY: ${{ vars.PROJECT_NAME || 'upscaler' }}-splitter-dev-ecr
#           IMAGE_TAG: ${{ github.sha }}
#         run: |
#           # Tag with SHA
#           docker tag ${{ env.CONTAINER_NAME }}:${{ github.sha }} $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
#           docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          
#           # Tag with 'latest'
#           docker tag ${{ env.CONTAINER_NAME }}:${{ github.sha }} $ECR_REGISTRY/$ECR_REPOSITORY:latest
#           docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
          
#           # Tag with short SHA
#           SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
#           docker tag ${{ env.CONTAINER_NAME }}:${{ github.sha }} $ECR_REGISTRY/$ECR_REPOSITORY:$SHORT_SHA
#           docker push $ECR_REGISTRY/$ECR_REPOSITORY:$SHORT_SHA
          
#           # Output full image URI
#           IMAGE_URI="${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}"
#           echo "image-uri=${IMAGE_URI}" >> $GITHUB_OUTPUT
#           echo "Pushed image: ${IMAGE_URI}"

#       - name: Scan image in ECR
#         run: |
#           aws ecr start-image-scan \
#             --repository-name ${{ vars.PROJECT_NAME || 'upscaler' }}-splitter-dev-ecr \
#             --image-id imageTag=${{ github.sha }} \
#             --region ${{ vars.AWS_REGION || env.AWS_REGION }} || true

  # ============================================================================
  # Update Batch Job Definition
  # ============================================================================
#   update-batch-job:
#     name: Update Batch Job Definition
#     needs: push-dev
#     runs-on: ubuntu-latest
#     environment:
#       name: dev
    
#     steps:
#       - name: Checkout code
#         uses: actions/checkout@v4

#       - name: Configure AWS Credentials
#         uses: aws-actions/configure-aws-credentials@v4
#         with:
#           role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
#           aws-region: ${{ vars.AWS_REGION || env.AWS_REGION }}
#           role-session-name: GitHubActions-Batch-Update-Dev

#       - name: Get current job definition
#         id: current-job
#         run: |
#           JOB_DEF_NAME="${{ vars.PROJECT_NAME || 'upscaler' }}-splitter-job-dev"
          
#           # Get the latest active revision
#           LATEST_DEF=$(aws batch describe-job-definitions \
#             --job-definition-name "$JOB_DEF_NAME" \
#             --status ACTIVE \
#             --query 'jobDefinitions[0]' \
#             --output json)
          
#           if [ "$LATEST_DEF" = "null" ] || [ -z "$LATEST_DEF" ]; then
#             echo "No active job definition found for: $JOB_DEF_NAME"
#             echo "job-exists=false" >> $GITHUB_OUTPUT
#           else
#             echo "job-exists=true" >> $GITHUB_OUTPUT
#             echo "$LATEST_DEF" > /tmp/current-job-def.json
#           fi

#       - name: Register new job definition revision
#         if: steps.current-job.outputs.job-exists == 'true'
#         id: register-job
#         run: |
#           # Read current definition
#           CURRENT_DEF=$(cat /tmp/current-job-def.json)
          
#           # Update the image URI in the container definition
#           NEW_IMAGE_URI="${{ needs.push-dev.outputs.ecr-image-uri }}"
          
#           # Extract and update container properties
#           UPDATED_DEF=$(echo "$CURRENT_DEF" | jq --arg img "$NEW_IMAGE_URI" '
#             .containerProperties.image = $img |
#             del(.jobDefinitionArn, .revision, .status, .registeredAt, .registeredBy)
#           ')
          
#           # Register new revision
#           NEW_REV=$(aws batch register-job-definition \
#             --cli-input-json "$UPDATED_DEF" \
#             --output json)
          
#           NEW_REVISION=$(echo "$NEW_REV" | jq -r '.revision')
#           echo "new-revision=$NEW_REVISION" >> $GITHUB_OUTPUT
#           echo "Successfully registered job definition revision: $NEW_REVISION"

#       - name: Create job definition if not exists
#         if: steps.current-job.outputs.job-exists == 'false'
#         run: |
#           echo "‚ö†Ô∏è No active job definition found. You may need to run Terraform apply first."
#           echo "Terraform will create the initial job definition with the container image."
#           exit 1

#       - name: Summary
#         run: |
#           echo "## Deployment Summary" >> $GITHUB_STEP_SUMMARY
#           echo "" >> $GITHUB_STEP_SUMMARY
#           echo "‚úÖ **Container Image Pushed:** ${{ needs.push-dev.outputs.ecr-image-uri }}" >> $GITHUB_STEP_SUMMARY
#           echo "‚úÖ **Job Definition Updated:** Revision ${{ steps.register-job.outputs.new-revision }}" >> $GITHUB_STEP_SUMMARY
#           echo "" >> $GITHUB_STEP_SUMMARY
#           echo "### Next Steps" >> $GITHUB_STEP_SUMMARY
#           echo "- New Batch jobs will automatically use the updated image" >> $GITHUB_STEP_SUMMARY
#           echo "- Monitor CloudWatch Logs for job execution" >> $GITHUB_STEP_SUMMARY
#           echo "- Verify functionality with a test job submission" >> $GITHUB_STEP_SUMMARY

#   # ============================================================================
#   # Optional: Run Integration Test
#   # ============================================================================
#   test-integration:
#     name: Run Integration Test (Optional)
#     needs: update-batch-job
#     if: github.ref == 'refs/heads/main' && vars.RUN_INTEGRATION_TESTS == 'true'
#     runs-on: ubuntu-latest
#     environment:
#       name: dev
    
#     steps:
#       - name: Checkout code
#         uses: actions/checkout@v4

#       - name: Configure AWS Credentials
#         uses: aws-actions/configure-aws-credentials@v4
#         with:
#           role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
#           aws-region: ${{ vars.AWS_REGION || env.AWS_REGION }}
#           role-session-name: GitHubActions-Integration-Test

#       - name: Upload test video to S3
#         run: |
#           # TODO: Upload a small test video to S3
#           echo "Integration test placeholder - implement test video upload"

#       - name: Submit test Batch job
#         id: submit-job
#         run: |
#           # TODO: Submit a test job to Batch
#           echo "Integration test placeholder - implement job submission"

#       - name: Wait for job completion
#         run: |
#           # TODO: Poll job status and wait for completion
#           echo "Integration test placeholder - implement job monitoring"

#       - name: Verify outputs
#         run: |
#           # TODO: Check that segments and manifest were created correctly
#           echo "Integration test placeholder - implement output verification"
